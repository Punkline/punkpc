/*## Header:
# --- Enumerator Tools
# Basic tools for assigning indices and mask bools to a list of symbol names

##*/
/*## Attributes:
# Volatile Working Properties:
# --- i - volatile loop counter
# --- a - volatile argument flag

# --- Class Properties ---

# --- enum.count  - shared index counter
# --- enum.step   - shared index step
# --- enumb.count - shared boolean index counter
# --- enumb.step  - shared boolean index step
# --- enumb.mask  - generated combination of masks with their boolean TRUE/FALSE values
# --- enumb.crf   - output crf mask, for using mtcrf instructions to load in enumb.mask


# --- Class Methods ---

# --- enum        Sym, Sym, ...
# An enumerator tool that lets you assign iterations of a counting number to a sequence of names
#  - if sym starts with an symbol-friendly character, then it will be assigned a step in the count
#  - if sym starts with a + or a -, it is considered as an argument step amount, for counter
#  - if sym is (enclosed in parentheses) then it is considered as an argument index, to set counter

# --- enumb       Sym, Sym, ...
# Bool enumerator; creates aliases of given symbols to generate boolean indicies and masks
#  - generated mSym = mask of this bool;              ex: mSym = 0x00040000
#  - generated bSym = big-endian index of this bool;  ex: bSym = 13

# --- enumb.mask  Sym, Sym, ...
# A method that evaluates given symbol names, and uses their aliases to build a combined mask
#  - if 'Sym' does not exist, but 'mSym' does - then value is assumed false

# --- enum.pfx        pfx, Sym, Sym, ...
# --- enumb.pfx       pfx, Sym, Sym, ...
# --- enumb.mask.pfx  pfx, Sym, Sym, ...
# Variations of the class methods that concatenate each symbol to a given prefix namespace



# --- Constructor Methods ---

# --- enum.new   name, pfx, Sym, Sym, ...
# A constructor for making objects that can perform an 'enum' method with a private counter
# - if pfx is blank "", then it will be unused
# - if symbols are not provided, they can be added later by invoking the new object by name

# --- Object Properties ---

  # --- .last   - keeps memory of the last assigned count
  # --- .count  - these 4 properties are like internal versions of the Class Properties
  # --- .step
  # --- .mask
  # --- .crf
  # --- .count.restart - these keep the initial properties set by the object constructor
  # --- .step.restart  - they will be applied when using the '.restart' method

# --- Object Methods ---
  # --- (self)  Sym, Sym, ...
  # Just like the 'enum.pfx' Class method, but also internalizes an optional prefix

  # --- .bool  Sym, Sym, ...
  # Just like the 'enumb.pfx' Class method, but internalizes an optional prefix

  # --- .mask   Sym, Sym, ...
  # Just like the 'enumb.mask.pfx' Class method, but internalizes an optional prefix

  # --- .restart
  # restarts the enumerator object back to its initial counter/step settings

  # --- .bool.restart
  # a version of '.restart' that operates on the bool enumerator instead of the int enumerator

# --- Overridable Callback Methods ---
  # --- .enum_callback               self, sym, pfx, sfx
  # --- .enum.bool_callback          self, sym, pfx, sfx
  # --- .enum.mask_callback          self, pfx
  # --- .enum.restart_callback       self, pfx
  # --- .enum.bool.restart_callback  self, pfx
  # These do nothing by default, but can be programmed to do something by purging and redefining
  # - self is a copy of the enumerator object's name
  # - sym is the whole symbol that has just been generated by enum or enum.bool
  # - pfx is the common prefix name given to all symbols of this enumerator
  # - sfx is the specific name of this symbol generated by this enumerator


##*/
/*## Examples:
.include "./punkpc/enum.s"


# --- ENUMERATIONS ---
enum A B C D  # enumerate given symbols with a count; starting with 0, and incrementing by +1
enum E F G H  # ... next call will continue previous enumerations...
# >>>  A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7

enum (31)     # re-orient enumeration value so that count will start at 31, using ( ) parentheses
enum -4       # set enumeration to increment/decrement by a specific amount with +/-
enum I, +1, J K L  # these can be in-line with symbol arguments
# >>>  I=31, J=27, K=28, L=29

enum (31),-1,rPlayer,rGObj,rIndex,rCallback,rBools,rCount
# enumerate register names ...

sp.xWorkspace=0x220
enum (sp.xWorkspace),+4,VelX,VelY,RotX,RotY,RGBA
# enumerate offset names ...
# etc..


# --- BOOL ENUMERATIONS ---
enumb Enable, UseIndex, IsStr
# state the bool symbol names you want to use:
# >>> bEnable   = 31; mEnable   = 0x00000001
# >>> bUseIndex = 30; mUseIndex = 0x00000002
# >>> bIsStr    = 29; mIsStr    = 0x00000004
# mMask and bBit symbols are created for each

enumb (0), +1, A, B, C
# >>> bA = 0; mA = 0x80000000
# >>> bB = 1; mB = 0x40000000
# >>> bC = 2; mC = 0x20000000

.long mA|mB|mC
# >>> 0xE0000000

rlwinm. r3, r0, 0, bUseIndex, bUseIndex
rlwinm. r3, r0, 0, mUseIndex
# both of these rlwinms are identical

rlwimi r0, r0, bIsStr-bC, mC
# insert bIsStr into bC in a single register/instruction


# --- BOOL MASK GENERATOR ---

enumb.restart
# you can reset the counter back to its default position this way, to make a new mask

enumb Enable, UseIndex, IsStr       # state the bool symbol names you want to use
Enable = 1; UseIndex = 1;           # set some boolean values as T/F
# unassigned bool IsStr is assumed to be 0

enumb.mask Enable, UseIndex, IsStr  # generate a mask with said bools using 'enumb.mask'
# this uses the mMask value and the state values to create a combined state mask

m=enumb.mask;  .long m              # mask will compile from given 'enumb' index values
# you can save the combined mask by copying the return enumb.mask property
# >>> 0x00000003

crf=enumb.crf;  mtcrf crf, r0
# you can move partial fields directly into the volatile CR registers with mtcrf, and enumb.crf

bf- bEnable, 0f
bf- bIsStr, 1f; nop; 1:
bt+ bUseIndex, 0f; nop; 0:
# once in the CR, each bool can be referenced by name in 'bf' or 'bt' branch instructions


# --- ENUM PREFIXES ---
enum.pfx "myNamespace.", -4, (0x10), A, B, C, D
.byte myNamespace.A, myNamespace.B, myNamespace.C, myNamespace.D
# - pfx allows first argument to create a prefix substring added to the beginning of each input name
# - doesn't need to be in quotes, but it makes the syntax a bit more readible and doesn't interfere


# --- ENUMERATOR OBJECTS ---

enum.new myStruct, "struct.", +4, (0)  # creates an enumerator object called 'myStruct'
# - the second argument creates a prefix name that gets attached to the beginning of each input name

enum.new myRegs, "", -1, (r31)  # creates an enumerator object called 'myRegs'
# - a blank second argument will use a 'blank' prefix that generates the given symbol names directly
myRegs   rPrev, rNext, rColor, rData, rStr, rID, rPriority, rBools
myStruct xPrev, xNext, xColor, xData, xStr, +1, xID, xPriority, +2, xBools

lwz rPrev,     struct.xPrev(r3)     # 0x00, r31
lwz rNext,     struct.xNext(r3)     # 0x04, r30
lwz rColor,    struct.xColor(r3)    # 0x08, r29
lwz rData,     struct.xData(r3)     # 0x0C, r28
lwz rStr,      struct.xStr(r3)      # 0x10, r27
lbz rID,       struct.xID(r3)       # 0x14, r26
lbz rPriority, struct.xPriority(r3) # 0x15, r25
lhz rBools,    struct.xBools(r3)    # 0x16, r24
# load struct vars into named registers using named offsets

myRegs.restart
myRegs rThis, rThat
# the '.restart' method can be used to restart the counter/step back to its original settings

lwz rThis, 0x00(r4)
lwz rThat, 0x10(r4)
stmw myRegs.last, 0x10(sp)
# the '.last' property saves the last assigned count value, and can be used in stmw/lmw instructions

myRegs.restart
myRegs rThese, rThose, rSize
lwz rThese, 0x0(r5)
lwz rThose, 0x8(r4)
li rSize, myStruct.count
stmw myRegs.last, 0x20(sp)
# the '.count' property memorizes the next count value to assign, and can be used to reference sizes

myStruct.bool Enable, UseIndex, IsStr
# >>> struct.bEnable   = 31; struct.mEnable   = 0x00000001
# >>> struct.bUseIndex = 30; struct.mUseIndex = 0x00000002
# >>> struct.bIsStr    = 29; struct.mIsStr    = 0x00000004


# --- ENUMERATOR OBJECT MUTATORS---
# Version 0.1.0 onward has expanded the callbacks system to include overridable default methods
# - these provide the functionality of a default enumerator, but can be purged and re-defined
# - additionally, a handful of dummy object events provide hooks that can extend without overwriting

myStruct.restart
# restart 'myStruct' enumerator

# Here is a very straight-forward way of defining mutated behavior:

.purgem myStruct.cb.enum_plugin
.macro  myStruct.cb.enum_plugin, self, symbol, pfx, sfx
# purge the '.enum_plugin' dummy method so that we can define it in this macro:

  # self   is the namespace of the object, in case passing through more generic macros is necessary
  # symbol is the full name of the enumerated symbol argument that was just processed
  # pfx    is the prefix namespace used for the symbol, to access properties belonging to it
  # sfx    is the suffix namespace used for the symbol, for adding substrings in the middle of names

  # for this, we'll only use 'symbol', which has sampled the value of this enumerator's count

  .long \symbol
  # this will simply emit numbers recording the enumerated count of the structure we write

.endm
# now that the callback is defined, it's safe to execute the mutated object

myStruct xPrev, xNext, xColor, xData, xStr, +1, xID, xPriority, +2, xBools
# >>> 00000000 00000004
# >>> 00000008 0000000C
# >>> 00000010 00000014
# >>> 00000015 00000016
# now, the myStruct enumerator also emits a word for each offset created in the struct
# - this is our mutation behavior, described by '.enum_plugin'

# Another way to do this is to make your own named macro, and give its name to 'enum.mut'

enum.mut myStruct, plugin, myStructMutator
# object name, callback type, callback name
# - now we define a macro named 'myStructMutator'

.macro myStructMutator, self, sym, pfx, sfx
  .long 0x1337 + \sym
  # a cooler version of our old mutation

.endm
# now that the callback is defined, it's safe to execute the mutated object

mystruct.restart
myStruct xPrev, xNext, xColor, xData, xStr, +1, xID, xPriority, +2, xBools
# >>> 00000000 00000004
# >>> 00000008 0000000C
# >>> 00000010 00000014
# >>> 00000015 00000016
# now, the myStruct enumerator also emits a word for each offset created in the struct
# - this is our mutation behavior, described by '.enum_plugin'


##*/

.ifndef enum.included; enum.included = 0; .endif; .ifeq enum.included; enum.included = 0x100
# --- version 0.1.0
# - completely remodeled object system to be mutator-based
# - added sidx.s and ifalt.s to module, for 4D scalars and altmacro mode checks
# - removed 'enum.bool' and 'enum.bool_reset' methods in favor of mutated 'enum' and 'enum_reset'
# - added new state flags that can be used to drive the enumerator parse through callbacks
# - fleshed out callback system to support many new method mutators
# - added a generic mutator class method that can be used to assign macros in place of obj methods
# - remodeled character parse to be mutable, so that you can add new types of argument syntaxes

# version 0.0.5
# - fixed bug in original code that was preventing crf from updating correctly in .mask methods
# - merged the enum and enumb constructors into one class
# - provided mutators that create backwards compatability with old enumb namespaces
# - remamed '.reset' to '.restart' to avoid conflict with stack method names
# - created a separate restart method for bool counting
# - added overridable dummy callbacks to object methods
# version 0.0.4
# - added '.reset' methods to enumerator objects
# - added a '.last' and '.reset' property for enumerator objects
# version 0.0.3
# - added varargs to constructors, so initial settings can be added to enum generators
# - updated documentation attributes
# version 0.0.2
# - added xem.s to module, for register names
# - added *.pfx variants of old functions, to support prefix namespaces
# - added a constructor, for instantiating enumerators with a private count, and name

.include "./punkpc/enc.s"  # for sidx, stacks, and encoding tools
.include "./punkpc/xem.s"  # for register names

enum$=0 # object instance counter

# these constructors let you make an integer enumerator or a bool enumerator
# - bool enumerators create names with m- and b- prefixes

.macro enum.mut, self, type, cb
ifdef \self\().isEnum
  .if def;   .purgem \self\().cb.\type
    .ifb \cb; .macro \self\().cb.\type, va:vararg; enum.defcb.\type \va; .endm;
    .else;    .macro \self\().cb.\type, va:vararg; \cb \va; .endm; .endif
  .endif
  # This creates an easy-to-use mutator method
  # - if no callback name is given, then the default is re-set


# --- Default Callback Mappings:

# The following are default methods used by the class module
#  'dummy hooks' can be overridden to add new functionality without replacing any behavior
# - other methods can be overridden to replace the normal behavior with something different
# - each object instance may re-configure its object methods to use different callbacks
#   - the following 'defcb' definitions are used as defaults if no custom callback is stated

# enum:
.endm; .macro enum.defcb.enum_pre,      self, prefix, va:vararg
  # - dummy hook
  # - at the very beginning of the enum call

.endm; .macro enum.defcb.enum_blank,    self, prefix
  # - dummy hook
  # - when a blank argument is detected -- runs in place of any other handle

.endm; .macro enum.defcb.enum_post,     self, prefix, va:vararg
  # - dummy hook
  # - at the very ending of the enum call


# enum_map:
# - the part of enum that checks if argument prefixes are to be handled by a mapped callback
.endm; .macro enum.defcb.enum_map_pre,   self, symbol, prefix, suffix, chars, first
  # - dummy hook
  # - before each map element is checked

.endm; .macro enum.defcb.enum_map,       self, symbol, prefix, suffix, chars, first
  # for each argument -- before enum_proc step
  # - checks if starting chacters of this argument denote some sort of special handling
  # - + - and ( are checked for by default objects
  .if \self\().enum_map$; \self\().enum_map$0 \symbol, \prefix, \suffix, \chars, \first; .endif

.endm; .macro enum.defcb.enum_map_plugin, self, symbol, prefix, suffix, chars, first
  # - dummy hook
  # - after enum map has been checked, but before it has been handled

.endm; .macro enum.defcb.enum_map_pre,   self, symbol, prefix, suffix, chars, first
  # - dummy hook
  # - after enum map element has been checked and handled

.endm; .macro enum.defcb.new_step_pre,  self, prefix, step
  # - dummy hook
  # - before a new step value is assigned

.endm; .macro enum.defcb.new_step,      self, prefix, step
  \self\().step = \step
  # sets the step property to a new value

.endm; .macro enum.defcb.new_step_post, self, prefix, step
  # - dummy hook
  # - after a new step value is assigned

.endm; .macro enum.defcb.new_count_pre, self, prefix, count
  # - dummy hook
  # - before a new count value is assigned

.endm; .macro enum.defcb.new_count,     self, prefix, count
  \self\().count = \count
  # sets the count property to a new value

.endm; .macro enum.defcb.new_count_post,self, prefix, count
  # - dummy hook
  # - after a new count value is assigned


# enum_proc:
# - part of enum that handles non-mapped (enumerated) arguments
# - gets skipped if '.enum_skip' is not False
.endm; .macro enum.defcb.enum_proc_pre, self, symbol, prefix, suffix
  # - dummy hook
  # - before each enumerated argument is processed

.endm; .macro enum.defcb.enum_proc,     self, symbol, prefix, suffix
  # for each enumerated argument...

.endm; .macro enum.defcb.enum_proc_post,self, symbol, prefix, suffix
  # - dummy hook
  # - after each enumerated argument has been processed

.endm; .macro enum.defcb.enum_proc_assign,self, symbol, prefix, suffix
  \symbol = \self\().count
  # default assignment behavior, for default enum_proc behavior

.endm; .macro enum.defcb.enum_proc_count, self, symbol, prefix, suffix
  \self\().last = \self\().count
  \self\().count = \self\().count + \self\().step;
  \self\().steps = \self\().steps + 1
  # default counting behavior, for default enum_proc behavior

.endm; .macro enum.defcb.enum_proc_plugin,self, symbol, prefix, suffix
  # - dummy hook
  # - after assign and count have finished, if not skipping this enum_proc


# enumb:
# - plugin can intercept what bit is inserted by modifying '.mask_bit'
# - plugin can disable this insertion by setting '.mask_skip' to a non-0 value
.endm; .macro enum.defcb.enum_assign_bool, self, symbol, prefix, suffix
  \prefix\()b\suffix = \self\().count & 31
  \prefix\()m\suffix = 0x80000000 >> \self\().count
  # alternative assignment can be used to mutate a default enum object into an enumb object



# mask:
.endm; .macro enum.defcb.mask_pre,      self, prefix, va:vararg
  # - dummy hook
  # - before mask even starts check/insert loop

.endm; .macro enum.defcb.mask_check,    self, symbol, prefix, suffix
  ifnum \symbol;
  .if nnum  ifdef \symbol; .if ndef; \symbol = 0; .endif
    ifdef \prefix\()m\suffix;
    .if def;  \self\().mask_bit = \symbol
    .else;    \self\().mask_bit = \prefix\()m\suffix; .endif;  .endif
  # checks if symbol exists, and if it doesn't then it gets assigned the value of 0
  # also checks if mask exists, and if it doesn't then it gets assigned the value of symbol

.endm; .macro enum.defcb.mask_plugin,   self, symbol, prefix, suffix
# - dummy hook
# - after each symbol has been checked, but before it has been inserted

.endm; .macro enum.defcb.mask_insert,   self, symbol, prefix, suffix
    .if \symbol; \self\().mask = \self\().mask | \self\().mask_bit; .endif
    \self\().mask_range = \self\().mask_range  | \self\().mask_bit
    # if the symbol isn't null
    # and there's a mask symbol for it...
    #    ... then OR in the mask to working mask
    # else, if no mask symbol was found...
    #    ... then OR in the symbol to working mask

.endm; .macro enum.defcb.mask_crf       self, prefix
  \self\().crf = (\self\().crf<<1)|!!(\self\().mask_range & 0xF0000000)
  # generates a crf bit for each nibble containing at least 1 bit in working mask range

.endm; .macro enum.defcb.mask_post,     self, prefix, va:vararg
# - dummy hook
# - after mask has finished check/insert loop


# mask_clear:
.endm; .macro enum.defcb.mask_clear,    self, prefix
  \self\().mask = 0
  \self\().mask_range = 0
  \self\().mask_bit = 0
  # clears the working mask by nullifying properties


# restart:
.endm; .macro enum.defcb.restart_pre,   self, prefix
  # - dummy hook
  # - before restart

.endm; .macro enum.defcb.restart,       self, va:vararg
  \self\().count = \self\().count.restart
  \self\().step = \self\().step.restart
  \self\().steps = 0

.endm; .macro enum.defcb.restart_post,  self, prefix
  # - dummy hook
  # - after restart


# End of default callback mappings


# --- Constructors
.endm; .macro enumb.new, va:vararg; enum.new.bool \va
.endm; .macro enum.new.bool, self, pfx="", step=-1, count=31, va:vararg;
  enum.new \self, \step, (\count), \va
  enum.mut \self, enum_assign, enum.defcb.enum_assign_bool
  # enumb.new and enum.new.bool create an enumerator with a mutated assignment operation

.endm; .macro enum.new, self, prefix, varg:vararg
  ifdef \self\().isEnum
  .if ndef; enum$ = enum$ + 1; \self\().isEnum = enum$
    \self\().count  = 0
    \self\().last   = 0
    \self\().step   = 1
    \self\().enum.skip = 0
    \self\().enum.counting = 1
    \self\().enum.assigning = 1
    \self\().enum.exit = 0
    \self\().mask = 0
    \self\().crf = 0
    .macro \self, va:vararg; \self\().pfx, \va
      # main method is just a shortcut for using pre-defined prefix in self.pfx:

    .endm; .macro \self\().pfx, pfx=\prefix, va:vararg;
      \self\().cb.enum_pre \self, \pfx
      .irp a,  \va;
      # for each argument...
        .ifb \a; \self\().cb.enum_blank \self, \pfx
          # optionally handle blank args with a mutator

        .else # else, if not blank:
          .if \self\().enum.skip > 0; \self\().enum.skip = \self\().enum.skip - 1; .endif
          .if \self\().enum.exit;
            .if \self\().enum.exit > 0; \self\().enum.exit = self.enum.exit - 1; .endif; .exitm
          .endif # these decrement the skip and exit counters, if they're above 0
          # - also exits loop if exit flag is found

          \self\().cb.enum

          .irpc c,  \a
            .irpc i,  -+
              .ifc \c,  \i;
                \self\().enum.skip = \self\().enum.skip + 1
                \self\().cb.enum_new_step_pre  \self, \pfx, \self\().step
                \self\().cb.enum_new_step      \self, \pfx, \self\().step
                \self\().cb.enum_new_step_post \self, \pfx, \self\().step
              .endif;
            .endr;
            .ifc \c,  (;
              \self\().enum.skip = \self\().enum.skip + 1
              \self\().cb.enum_new_count_pre  \self, \pfx, \self\().count
              \self\().cb.enum_new_count      \self, \pfx, \self\().count
              \self\().cb.enum_new_count_post \self, \pfx, \self\().count
            .endif;
            .exitm;
          .endr; # checks for +n, -n, or (n) syntaxes
          # - enum.skip will cause the counting/assignment step to be skipped if not 0
          # - if enum.skip is set to a number larger than 0, it will count down
          # - if set below 0, it will stay skipping indefinitely -- until reset manually

          .if \self\().enum.skip == 0
            .if \self\().enum.assigning;
              \self\().cb.enum_assign  \self, \pfx\a, \pfx, \a
            .endif
            .if \self\().enum.counting
              \self\().cb.enum_count   \self, \pfx\a, \pfx, \a
            .endif
            \self\().cb.enum_plugin    \self, \pfx\a, \pfx, \a
          .endif # count/assignment step
        .endif
      .endr; \self\().cb.enum_post \self, \pfx
    .endm; .macro \self\().bool, va:vararg;
      .irp a,  \va;  a=1
        .irpc c,  \a
          .irpc i,  -+;
            .ifc \c,  \i;  \self\().bool.step=\a;a=0;.endif;
            .ifc \c,  (;  \self\().bool.count=\a;a=0;.endif;.endr;.exitm;.endr;
        .if a;
          ifdef \pfx\a; .if ndef; \pfx\a = 0; .endif
          \pfx\()b\a  = \self\().bool.count
          \pfx\()m\a = 0x80000000 >> \pfx\()b\a
          \self\().bool.last=\self\().bool.count
          \self\().bool.count = \self\().bool.count + \self\().bool.step
          \self\().enum.bool_callback \self, \pfx\a, \pfx, \a
        .endif
      .endr
    .endm; .macro \self\().mask, va:vararg;
      i=0; a=0; .irp a,  \va;  ifdef \pfx\a
        .if ndef;  \pfx\a=0;.endif; ifdef \pfx\()m\()\a
        .if ndef;  \pfx\()m\()\a=0;.endif;
        i=i | (\pfx\()m\a & (\pfx\a != 0));
        a=a | (\pfx\()m\a)
      .endr; \self\().mask=i;\self\().crf=0
      .rept 8;  \self\().crf=(\self\().crf<<1)|!!(a&0xF0000000)
        a=a<<4; .endr; crf = \self\().crf; \self\().enum.mask_callback \self, \pfx
    .endm; .macro \self\().restart;
      \self\().enum.restart_callback \self, \pfx
      \self\().count = \self\().count.restart
      \self\().step = \self\().step.restart
    .endm; .macro \self\().bool.restart;
      \self\().enum.bool.restart_callback \self, \pfx
      \self\().bool.count = \self\().bool.count.restart
      \self\().bool.step = \self\().bool.step.restart
    # int and bool enumerator methods

    # The following are overridable callbacks that the enumerator object executes
    # Any callbacks that remain empty will act like NOPs
    # - you can purge and re-define these with '.purgem macro_name'
    # - you can control whether or not the enumerator continues with each callback event
    #   - set the '.counting' property flag to 0 to stop the enumerator from counting up/down
    #   - set the '.assigning' property flag to 0 to stop the enumumerator from assigning values
    #   - set the '.skip' property flag to skip the next iteration
    #   - set the '.exit' property flag to skip the next call

    # The events for the enumerator are executed in the order that they are defined:
    # _pre    - hook is executed once before anything happens in the enumerator method
    # _count  - executes for each symbol; responsible for counting when '.counting' is enabled
    # _assign - executes for each symbol; responsible for assigning when '.assigning' is enabled
    # _plugin - executes for each symbol; a post-assignment hook
    # _post   - hook is executed once after the method has finished

    .endm; .macro \self\().cb.enum_pre,    va:vararg; enum.defcb.enum_pre \self, \va
    .endm; .macro \self\().cb.enum,        va:vararg; enum.defcb.enum \self, \va
    .endm; .macro \self\().cb.enum_map,    va:vararg; enum.defcb.enum_map \self, \va
    .endm; .macro \self\().cb.enum_count,  va:vararg; enum.defcb.enum_count \self, \va
    .endm; .macro \self\().cb.enum_assign, va:vararg; enum.defcb.enum_assign \self, \va
    .endm; .macro \self\().cb.enum_plugin, va:vararg; enum.defcb.enum_plugin \self, \va
    .endm; .macro \self\().cb.enum_post,   va:vararg; enum.defcb.enum_post \self, \va
    # obj    = the object name for this enumerator
    # symbol = the symbol being counted/assigned a count value
    # prefix = the prefix baked into this enumerator (can be blank)
    # suffix = the suffix of the symbol, excluding the prefix
    # va     = the comma-separated arguments that will be or have been used by this method call

    .endm; .macro \self\().cb.enum_new_step_pre,   va:vararg; enum.defcb.new_step_pre \self, \va
    .endm; .macro \self\().cb.enum_new_step,       va:vararg; enum.defcb.new_step \self, \va
    .endm; .macro \self\().cb.enum_new_step_post,  va:vararg; enum.defcb.new_step_post \self, \va
    .endm; .macro \self\().cb.enum_new_count_pre,  va:vararg; enum.defcb.new_count_pre \self, \va
    .endm; .macro \self\().cb.enum_new_count,      va:vararg; enum.defcb.new_count \self, \va
    .endm; .macro \self\().cb.enum_new_count_post, va:vararg; enum.defcb.new_count_post \self, \va
    # These are responsible for assigning new properties from the argument syntaxes
    # step  = +n, -n : changing the increment/decrement step size
    # count = (n)    : setting the counter to a new absolute value

    .endm; .macro \self\().cb.enum.mask_pre,    va:vararg; enum.defcb.mask_pre \self, \va
    .endm; .macro \self\().cb.enum.mask_check,  va:vararg; enum.defcb.mask_check \self, \va
    .endm; .macro \self\().cb.enum.mask_insert, va:vararg; enum.defcb.mask_insert \self, \va
    .endm; .macro \self\().cb.enum.mask_plugin, va:vararg; enum.defcb.mask_plugin \self, \va
    .endm; .macro \self\().cb.enum.mask_post,   va:vararg; enum.defcb.mask_post \self, \va
    # These are responsible for checking the value of and inserting masked elements into an array
    # - they are only used for boolean mask building -- but can be programmed to do otherwise

    .endm; .macro \self\().cb.enum.restart_pre, va:vararg; enum.defcb.restart_pre \self, \va
    .endm; .macro \self\().cb.enum.restart,     va:vararg; enum.defcb.restart \self, \va
    .endm; .macro \self\().cb.enum.restart_pre, va:vararg; enum.defcb.restart_pre \self, \va
    .endm # These are responsible for resetting any properties on restart

    .ifnb \varg; \self \varg; .endif
    \self\().count.restart = \self\().count
    \self\().step.restart = \self\().step
    \self\().bool.count.restart = \self\().bool.count
    \self\().bool.step.restart = \self\().bool.step
    # restart properties power the .restart method

  .endif
.endm


enum.new enum; enumb.new enumb
# initialize the global enum object, for general purpose use

.endif
/**/
