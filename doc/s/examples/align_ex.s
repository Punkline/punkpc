# --- Alignment Tool (relative)
#>toc library
# - an alternative to the `.align` directive that doesn't destroy absolute expressions
#   - relative addresses (labels) can't be measured after normal aligns using this directive
# - useful for measuring arbitrary body sizes that include un-aligned data
#   - byte arrays and strings are examples of structs that commonly need re-alignment

# --- Example use of the align module:

.include "punkpc.s"
punkpc align
# Use the 'punkpc' statement to load this module, or include the module file directly



# The assembler can align its program counter to a power of 2 with the .align directive
# ... however, this causes the program counter location to become unevaluable after the fact



show_errors = 0
# set this to 1 to display the following error:

.if show_errors
  0:
  .byte 1, 2, 3  # unaligned byte count, 3/4
  .align 2       # word alignment inserts a blank byte
  1:

  .if (1b - 0b) == 4    # This .if statement requires immediate evaluation...
    .long 1
  .else
    .long 0
  .endif
.endif

# In the above, we use '.align' to align the program counter
# ... but the expression made by the labels (1b - 0b) can't be evaluated until the assembly ends




# --- RELATIVE ALIGNMENT ---
# To get around this, the 'align' macro emits bytes relative to the current section
# - it does this by referencing a starting point generated by the 'punkpc' library object

0:
  .byte 1, 2, 3
  align 2
1:

.if (1b - 0b) == 4
  .long 1
.else
  .long 0
.endif
# >>> 1
# Now the expression is safe to use in .if statements
# - this basically just circumvents the unused linker feature to prevent obscurring the PC

# --- Example Results:

## 01020300 00000001
